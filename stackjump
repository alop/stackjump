#!/bin/sh

echo "\n## This tool should only be run on a Linux workstation ##"
echo "## This code is customized for AT&T environment usage only ##"
echo "## So far only tested on Precise Pangolin 12.04.3 x64 ##\n"

WHOAMI=`whoami`
if [ $WHOAMI != "root" ]; then
  echo "Must be run as sudo root"
  exit 1
fi

USAGE="$0 options
  -g chef-repo github url
  -a architecture [i386|amd64]
  -r release_codename (oneiric, natty, maverick, etc)
  -v release_version
  -rl chef run list for jump node (comma delimited)
  -o output iso
  -k keep tmp dir"

while [ $1 ];do
  case $1 in
    -g) shift
        GITH=$1;;
    -a) shift
        ARCH=$1;;
    -r) shift
        REL=$1;;
    -v) shift
        VER=$1;;
    -o) shift
        ISO=$1;;
    -rl) shift
         CHEFRUNLIST=$1;;
    -k) shift
        KEEP=1;;
    *) echo "$USAGE" && exit 1;;
  esac
  shift
done

TMPDIR="/tmp/stackjump"
if [ ! $REL ]; then
  REL='precise'
fi

ISODIR="$TMPDIR/ISO"
INITRD="$TMPDIR/initrd"

if [ ! -d $TMPDIR ]; then
  mkdir -p $TMPDIR
fi

if [ ! -d $ISODIR ]; then
  mkdir -p $ISODIR
fi

if [ ! -d $INITRD ]; then
  mkdir -p $INITRD
fi

## SANITY CHECKS ##

for BIN in fakeroot cpio mkisofs curl; do 
  if [ ! `which $BIN` ]; then
    echo "$BIN needs to be installed to run stackjump" && exit 1
  fi
done

if [ ! $ISO ]; then
  ISO='custom.iso'
fi

if [ ! $ARCH ]; then
  ARCH=`arch`
fi

case $ARCH in
  'i686') ARCH='i386';;
  'x86_64') ARCH='amd64';;
esac

if [ $ARCH != 'i386' ] && [ $ARCH != 'amd64' ]; then
  echo "Architecture $ARCH is not valid.  (amd64|i386)" && exit 1
fi

if [ ! $VER]; then
  VER='12.04.3'
fi
DISTURL="http://releases.ubuntu.com"
ISONAME="ubuntu-$VER-server-$ARCH.iso"
ISOURL="$DISTURL/$REL/$ISONAME"

HEAD=`curl -s --head $ISOURL|head -1`
HCODE=`expr "$HEAD" : 'HTTP\/... \(...\) '`
if [ "$HCODE" != '200' ]; then
  echo "Release $REL invalid."
  echo "Check $ISOURL to make sure a valid release codename" && exit 1
fi

if [ $GITH ]; then
  GITNAME=`expr $GITH : '.*github.com/\(.*\)'`
  if [ ! $GITNAME ]; then
    echo "$GITH invalid github repo url" && exit 1
  fi
  echo "Exporting GITHUB CHEF REPO..."
  OUTPUT=`(cd $TMPDIR ; curl -kLs https://github.com/$GITNAME/tarball/master|tar -zxv)`
  GITDIR="$TMPDIR/`echo $OUTPUT|awk '{print $1}'`"
  if [ ! $GITDIR ]; then
    echo "Unable to download GITHUB CHEF REPO tarball https://github.com/$GITNAME/tarball/master" && exit 1
  fi
fi

### MAKING THE ISO ##
if [ -f "$TMPDIR/$ISONAME" ]; then
  echo "$TMPDIR/$ISONAME exists - skipping download"
else
  echo "Downloading $ISOURL to $TMPDIR/$ISONAME"
  curl $ISOURL -o $TMPDIR
fi

MOUNTDIR="$TMPDIR/mount"
if [ ! -d $MOUNTDIR ]; then
  mkdir -p $MOUNTDIR
fi
if [ -d $MOUNTDIR/isolinux ]; then
  echo "ISO already mounted $MOUNTDIR - skipping mount"
else
  echo "Mounting to $MOUNTDIR..."
  mount -o loop $TMPDIR/$ISONAME $MOUNTDIR
fi
echo "Copying contents of $ISONAME to $ISODIR"
rsync -av $MOUNTDIR/ $ISODIR/

(cd $INITRD && gunzip -c $MOUNTDIR/install/initrd.gz| fakeroot cpio -id )

echo "CUSTOMIZING ISOLINUX.cfg"
cat>"$ISODIR/isolinux/isolinux.cfg"<<EOF
  prompt 0
  timeout 2
  menu hshift 13
  menu width 49
  menu margin 8
  default autoinstall
  
  label autoinstall
  MENU LABEL AUTOMATED INSTALL
  kernel /install/vmlinuz
  append auto ramdisk_size=14984 initrd=/install/initrd.gz vga=normal DEBCONF_DEBUG=5
EOF

echo "INJECTING PRESEED AND LATE|FIRST_RUN SCRIPTS"

cat>"$INITRD/preseed.cfg"<<EOF
d-i debian-installer/locale string en_US
d-i console-setup/ask_detect boolean false
d-i console-setup/layoutcode string us
d-i keyboard-configuration/layoutcode string us
d-i netcfg/link_detection_timeout string 3
d-i netcfg/disable_dhcp boolean true
d-i netcfg/dhcp_timeout string 1
d-i netcfg/dhcp_failed note
d-i netcfg/dhcp_options select Configure network manually
d-i netcfg/confirm_static boolean true
d-i netcfg/get_nameservers string 8.8.8.8
d-i netcfg/get_ipaddress string 172.16.199.199
d-i netcfg/get_netmask string 255.255.255.255
d-i netcfg/get_gateway string 172.16.199.199
d-i netcfg/get_hostname string jumpserver
d-i netcfg/get_domain string mydomain.com
d-i netcfg/get_hostname seen true 
d-i time/zone string UTC
d-i clock-setup/ntp boolean fales
#d-i clock-setup/ntp-server string time.apple.com
d-i clock-setup/utc boolean true
#d-i mirror/country string manual
#d-i mirror/http/hostname string us.archive.ubuntu.com
#d-i mirror/http/directory string /ubuntu
d-i mirror/http/proxy string
d-i partman-auto/method string regular
d-i partman-auto/purge_lvm_from_device boolean true
d-i partman-lvm/confirm boolean true
d-i partman-lvm/device_remove_lvm boolean true
d-i partman-auto/choose_recipe select atomic
d-i partman-partitioning/confirm_write_new_label boolean true
d-i partman/choose_partition select finish
d-i partman-auto/disk string /dev/sda
d-i partman/confirm boolean true
d-i partman/confirm_nooverwrite boolean true
d-i partman-md/confirm boolean true
d-i partman/choose_partition select finish
d-i partman/confirm boolean true
d-i passwd/root-login boolean false
d-i passwd/user-fullname string Ubuntu User
d-i passwd/username string ubuntu
d-i passwd/user-password-crypted password $6$Cjxz1rgM$ahShoUXrRY0qabPBMuFSmxRcwqkA2BRmb0B9Dlkzd5BfiunORoayXm3RZCEAsauW50JES9v1GTkkurnXmv8Ey0
d-i user-setup/encrypt-home boolean false
d-i pkgsel/include string openssh-server curl vim
d-i pkgsel/update-policy select none
bootstrap-base	base-installer/kernel/image	select	linux-generic-lts-raring
d-i pkgsel/install-language-support boolean false
tasksel tasksel/first multiselect standard, openssh-server
openssh-server ssh/new_config  boolean true
openssh-server ssh/use_old_init_script boolean true
openssh-server ssh/protocol2_only boolean true
openssh-server ssh/run_sshd boolean true
d-i preseed/late_command string cp -ar /extras/* /target; in-target chmod 755 /root/late_command.sh; in-target sh /root/late_command.sh; 
d-i grub-installer/only_debian boolean true
d-i grub-installer/with_other_os boolean true
d-i finish-install/reboot_in_progress note
EOF

EXTRAS="$INITRD/extras/root"
if [ ! -d $EXTRAS ]; then
  mkdir -p $EXTRAS
fi
cat>"$INITRD/extras/root/late_command.sh"<<EOF
EOF
#
#if [ ! -f $SOLOD/solo.rb ]; then
#  cat>$SOLOD/solo.rb<<EOF
#file_cache_path "/root/chef-solo"
#cookbook_path "/root/chef-solo/cookbooks"
#EOF
#fi
#
#if [ ! -f $SOLOD/solo.json ]; then
#  cat>$SOLOD/solo.json<<EOF
#{
#  "run_list": [ "recipe[chef-server::default]" ]
#}
#EOF
#fi
#
#RANDOMPW=`cat /dev/urandom| tr -dc 'a-zA-Z0-9' | fold -w 10| head -n 1`
#CHEFSEED="$CHEFS/files/default/chef-server.seed"
#if [ ! -f $CHEFSEED ]; then
#  echo "chef-server-webui chef-server-webui/admin_password password $RANDOMPW" >> $CHEFSEED
#  echo "chef-solr chef-solr/amqp_password password $RANDOMPW" >> $CHEFSEED
#fi
#
#RECIPE="$CHEFS/recipes/default.rb"
#if [ ! -f $RECIPE ]; then
#  cat>$RECIPE<<EOF
#if (platform?("ubuntu"))
#	package 'chef-server' do
#		action :install
#  		response_file "chef-server.seed"
#	end
#elsif (platform?("centos"))
#	package 'rubygem-chef-server' do
#		action :install
#	end
#end
#EOF
#fi
#
#FRUN="$ROOTD/first_run.sh"
#if [ ! -f $FRUN ]; then
#  cat>$FRUN<<EOF
##!/bin/sh
#if [ $PLATFORM = "ubuntu" ]; then
#  apt-get update
#  update-grub
#elif [ $PLATFORM = "centos" ];then
#  yum update -y
#fi
#CFDIR="/root/chef-solo"
#echo "installing chef-server"
#chef-solo -c \$CFDIR/solo.rb -j \$CFDIR/solo.json
#echo "done installing chef-server"
#if [ $PLATFORM = "centos" ]; then
#  setup-chef-server.sh
#fi
#ETC='/etc/chef'
#HOMEC='/home/ubuntu/.chef'
#mkdir \$HOMEC
#cp \$ETC/webui.pem \$HOMEC
#cp \$ETC/validation.pem \$HOMEC
#chown -R ubuntu \$HOMEC
#sleep 20
#echo "running knife configure -i for ubuntu user"
#su ubuntu -c "ruby /home/ubuntu/knife_first_run.rb"
#CHEFREPO="/home/ubuntu/chef-repo"
#chown -R ubuntu \$CHEFREPO
#FQDN=\`hostname --fqdn\`
#if [ ! -d \$CHEFREPO/cookbooks/apt ] ; then
#  if [ $PLATFORM = "ubuntu" ]
#    echo "install apt cookbook from community opscode"
#  s  u ubuntu -c "knife cookbook site install apt"
#  fi
#fi
#echo "uploading chef repo cookbooks..."
#( cd \$CHEFREPO ; su ubuntu -c "knife cookbook upload --all" )
#echo "running chef client to register"
#chef-client
#echo "listing /etc/chef"
#ls -ald /etc/chef/*
#echo "listing knife clients"
#su ubuntu -c "knife node list"
#echo "adding run list to admin node..."
#RUNLIST=\`cat \$CHEFREPO/admin_run_list\`
#for ckbk in \$RUNLIST; do
#  echo "knife node run_list add \$FQDN \$ckbk"
#  su ubuntu -c "knife node run_list add \$FQDN \$ckbk"
#done
#echo "running chef client to invoke run list"
#chef-client
#sleep 10
#if [ $PLATFORM = "ubuntu" ]; then
#  sed -i 's,sh /root/first_run.sh.*,exit 0,' /etc/rc.local;
#  sed -i '/^\*.*$/d' /etc/issue
#  reboot
#elif [ $PLATFORM = "centos" ]; then
#  sed -i 's/sh \/root\/first_run.sh.*//' /etc/rc.local;
#  sed -i '/^\*.*$/d' /etc/issue
#fi
#EOF
#fi
#
#USER_HOME="$INITRD/root_skel/home/ubuntu"
#mkdir -p $USER_HOME
#if [ ! -d $USER_HOME ]; then
#  echo "Unable to create $USER_HOME" && exit 1
#fi
#KFRUN="$USER_HOME/knife_first_run.rb"
#if [ ! -f $KFRUN ]; then
#  cat>$KFRUN<<EOF
##!/usr/bin/ruby
#require 'rubygems'
#require 'chef/knife'
#require 'ftools'
#homed='/home/ubuntu'
#homechf="#{homed}/.chef"
#repod="#{homed}/chef-repo"
#subcommand_loader = Chef::Knife::SubcommandLoader.new(false)
#commands_loaded = subcommand_loader.load_commands
#knifeconf = Chef::Knife::Configure
#knifeconf.load_deps
#instance = knifeconf.new(["configure", "-i"])
#instance.config[:config_file]="#{homechf}/knife.rb"
#instance.config[:chef_server_url]='http://localhost:4000'
#instance.config[:node_name]='ubuntu'
#instance.config[:admin_client_name]='chef-webui'
#instance.config[:admin_client_key]="#{homechf}/webui.pem"
#instance.config[:validation_client_name]='chef-validator'
#instance.config[:validation_key]="#{homechf}/validation.pem"
#instance.config[:repository]="#{repod}"
#instance.run_with_pretty_exceptions
#EOF
#fi
#
#if [ $PLATFORM = "ubuntu" ]; then
#  if [ ! -f $ROOTD/late_command.sh ]; then
#  cat>$ROOTD/late_command.sh<<EOF
#  #!/bin/sh
#  mkdir /root/.ssh
#  chmod 700 /root/.ssh /root/first_run.sh
#  mv /root/authorized_keys /root/.ssh
#  chmod 400 /root/.ssh/authorized_keys
#  sed -i 's,quiet splash,quiet,' /etc/default/grub
#  echo 'GRUB_GFXPAYLOAD_LINUX=text' >> /etc/default/grub
#  echo '**************************************************' >> /etc/issue
#  echo '* INSTALL NOT COMPLETE - WILL REBOOT MOMENTARILY *' >> /etc/issue
#  echo '**************************************************' >> /etc/issue
#  sed -i 's,exit 0,sh /root/first_run.sh > /root/first_run.log 2>&1,' /etc/rc.local;
#EOF
#  fi
#elif [ $PLATFORM = "centos" ]; then
#  if [ ! -f $ROOTD/late_command.sh ]; then
#    cat>$ROOTD/late_command.sh<<EOF
#  #!/bin/sh
#  mkdir /root/.ssh
#  chmod 700 /root/.ssh /root/first_run.sh
#  mv /root/authorized_keys /root/.ssh
#  chmod 400 /root/.ssh/authorized_keys
#  echo 'GRUB_GFXPAYLOAD_LINUX=text' >> /etc/default/grub
#  echo '**************************************************' >> /etc/issue
#  echo '* INSTALL NOT COMPLETE - WILL REBOOT MOMENTARILY *' >> /etc/issue
#  echo '**************************************************' >> /etc/issue
#  echo 'sh /root/first_run.sh > /root/first_run.log 2>&1' >> /etc/rc.local;
#EOF
#  fi
#fi
#
#REPOERR="invalid dir structure (see https://github.com/opscode/chef-repo)"
#SUBDIRS="cookbooks certificates config data_bags environments roles"
#valid_chef_repo() {
#  DIR=$1
#  for sdir in $SUBDIRS; do
#    if [ ! -d $DIR/$sdir ]; then
#      echo "$DIR $REPOERR" && exit 1
#    fi
#  done
#}
#
#CHEFREPO="$USER_HOME/chef-repo"
#if [ $CHEFCDIR ]; then
#  # local dir specified
#  valid_chef_repo $CHEFCDIR
#  (cd $CHEFCDIR ; git status > /dev/null 2>&1)
#  if [ $? != 0 ]; then
#    echo "$CHEFCDIR needs to be valid git repo (git init)" && exit 1
#  fi
#  cp -arp $CHEFCDIR $CHEFREPO
#elif [ $CHEFGITH ]; then
#  # remote github repo
#  if [ -d $CHEFREPO ]; then
#    rm -rf $CHEFREPO
#  fi
#  CHEFGITN=`expr $CHEFGITH : '.*github.com/\(.*\).git'`
#  if [ ! $CHEFGITN ]; then
#    echo "$CHEFGITH invalid github repo url" && exit 1
#  fi
#  echo "Exporting chef github repo..."
#  OUTPUT=`(cd $TMPDIR; curl -kLs https://github.com/$CHEFGITN/tarball/master|tar -zxv)`
#  CHEFGITDIR="$TMPDIR/`echo $OUTPUT|awk '{print $1}'`"
#  if [ ! $CHEFGITDIR ]; then
#    echo "Unable to download repo tarball" && exit 1
#  fi
#  valid_chef_repo $CHEFGITDIR
#  mv $CHEFGITDIR $CHEFREPO
#  CKBKDIR="$CHEFREPO/cookbooks"
#else
#  # no repo specified, so create empty chef-repo
#  echo "Creating empty chef repo..."
#  OPSCODE_URL='http://github.com/opscode/chef-repo/tarball/master'
#  OUTPUT=`(cd $TMPDIR ; curl -kLs $OPSCODE_URL|tar -zxv)`
#  OPSCODE_DIR="$TMPDIR/`echo $OUTPUT|awk '{print $1}'`"
#  mv $OPSCODE_DIR $CHEFREPO
#  if [ ! -d $CHEFREPO ]; then
#    echo "Failed creating empty chef repo" && exit 1
#  fi
#  (cd $CHEFREPO ; git init ; git add * ; git commit -am 'first commit') > /dev/null 2>&1
#fi
#RUNLISTF="$CHEFREPO/admin_run_list"
#
#check_runlist() {
#  for ckbk in $CHEFRUNLIST; do
#    if [ $ckbk = 'apt']; then
#      continue
#    fi
#    if [ ! -d $CKBKDIR/$ckbk ]; then
#      echo "$ckbk invalid cookbook" && exit 1
#    fi
#  done
#}
#
#if [ $CHEFRUNLIST ]; then
#  CHEFRUNLIST=`echo $CHEFRUNLIST| sed 's/,/ /g'`
#  check_runlist
#  echo $CHEFRUNLIST > $RUNLISTF
#elif [ -f $RUNLISTF ]; then
#  CHEFRUNLIST=`cat $RUNLISTF|sed 's/,/ /g'`
#  check_runlist
#else
#  CHEFRUNLIST='apt apt::cacher-ng'
#  echo $CHEFRUNLIST > $RUNLISTF
#fi
#
#echo "Making the ISO..."
## make the new initrd.gz
#(cd $INITRD ; find . | cpio -H newc --create | gzip -9 > $ISODIR/initrd.gz)
#
## iso it up
#mkisofs -q -r -V "Custom Install" -cache-inodes -J -l -b isolinux.bin -c boot.cat -no-emul-boot -boot-load-size 4 -boot-info-table -o $ISO $ISODIR
#if [ ! -f $ISO ]; then
#  echo "Create ISO failed." && exit 1
#else
#  if [ $KEEP ]; then
#    echo "Temp dir: $TMPDIR"
#  else
#    rm -rf $TMPDIR
#  fi
#  echo "$ISO successfully created" && exit 0
#fi
if [ -d $MOUNTDIR/isolinux ]; then
  umount $MOUNTDIR
fi
